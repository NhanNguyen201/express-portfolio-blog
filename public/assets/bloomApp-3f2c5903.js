import{S as e,d as n,e as s,A as t,W as i,V as o,j as r,i as a,P as c,h,T as d,D as m}from"./three.module-f98f4491.js";import{E as p,R as v,U as x,O as l}from"./OutputPass-f56cba18.js";import{m as u}from"./me_img-ffe0a782.js";const w=""+new URL("../rubyMat.jpg",import.meta.url).href,f={vertex:"\n        varying vec2 vUv;\n\n        uniform float uTime;\n\n        float PI = 3.141618;\n        float fre = 6.;\n\n        vec3 random3(vec3 c) {\n            float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n            vec3 r;\n            r.z = fract(512.0*j);\n            j *= .125;\n            r.x = fract(512.0*j);\n            j *= .125;\n            r.y = fract(512.0*j);\n            return r-0.5;\n        }\n        \n        const float F3 =  0.3333333;\n        const float G3 =  0.1666667;\n        \n        float snoise(vec3 p) {\n        \n            vec3 s = floor(p + dot(p, vec3(F3)));\n            vec3 x = p - s + dot(s, vec3(G3));\n             \n            vec3 e = step(vec3(0.0), x - x.yzx);\n            vec3 i1 = e*(1.0 - e.zxy);\n            vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n                 \n            vec3 x1 = x - i1 + G3;\n            vec3 x2 = x - i2 + 2.0*G3;\n            vec3 x3 = x - 1.0 + 3.0*G3;\n             \n            vec4 w, d;\n             \n            w.x = dot(x, x);\n            w.y = dot(x1, x1);\n            w.z = dot(x2, x2);\n            w.w = dot(x3, x3);\n             \n            w = max(0.6 - w, 0.0);\n             \n            d.x = dot(random3(s), x);\n            d.y = dot(random3(s + i1), x1);\n            d.z = dot(random3(s + i2), x2);\n            d.w = dot(random3(s + 1.0), x3);\n             \n            w *= w;\n            w *= w;\n            d *= w;\n             \n            return dot(d, vec4(52.0));\n        }\n        vec3 snoiseVec3( vec3 x ){\n        \n          float s  = snoise(vec3( x ));\n          float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n          float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n          vec3 c = vec3( s , s1 , s2 );\n          return c;\n        \n        }\n        \n        \n        vec3 curlNoise( vec3 p ){\n          \n          const float e = .1;\n          vec3 dx = vec3( e   , 0.0 , 0.0 );\n          vec3 dy = vec3( 0.0 , e   , 0.0 );\n          vec3 dz = vec3( 0.0 , 0.0 , e   );\n        \n          vec3 p_x0 = snoiseVec3( p - dx );\n          vec3 p_x1 = snoiseVec3( p + dx );\n        \n          vec3 p_y0 = snoiseVec3( p - dy );\n          vec3 p_y1 = snoiseVec3( p + dy );\n        \n          vec3 p_z0 = snoiseVec3( p - dz );\n          vec3 p_z1 = snoiseVec3( p + dz );\n        \n          float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n          float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n          float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n        \n          const float divisor = 1.0 / ( 2.0 * e );\n          return normalize( vec3( x , y , z ) * divisor );\n        \n        }\n        void main() {\n            vUv = uv;\n            float multi = pow(sin(uTime), 3.);\n            vec3 distorsion = curlNoise(vec3(position.x + uTime * 1.2, position.y + uTime * .05, 0.)) * multi;\n\n            vec3 finalPos = position +  distorsion;\n\n\n            gl_PointSize = 3.;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.);\n        }\n    ",fragment:"\n        uniform sampler2D uTexture1; \n        uniform sampler2D uShineTexture1; \n        uniform float uTime;\n\n        varying vec2 vUv;\n        \n\n       \n        void main() {\n            float mixer = pow(sin(uTime / 2.), 2.);\n\n\n            vec4 t1 = texture2D(uTexture1, vUv);\n            vec4 st1 = texture2D(uShineTexture1, vUv);\n        \n            vec4 mix1 = mix(st1, t1, step(0.35, dot(st1.rgb, vec3(1.))));\n            vec4 texture = mix(t1, mix1, smoothstep(0.45, 0.55, mixer));\n            gl_FragColor = texture;\n        }\n    "};class g{constructor({container:r,dom:a}){this.dom=a,this.container=r,this.scene=new e,this.clock=new n,this.progress=0,this.speed=Math.PI/240,this.camera=new s(45,window.innerWidth/window.innerHeight,.01,1e5),this.camera.position.x=0,this.camera.position.z=3,this.camera.position.y=0,this.ambient=new t({color:7697781}),this.scene.add(this.ambient),this.img=null,this.renderer=new i({canvas:this.dom,antialias:!0}),this.renderer.setSize(this.container.clientWidth,this.container.clientHeight),this.composer=new p(this.renderer),this.composer.addPass(new v(this.scene,this.camera)),this.bloomPass=new x(new o(this.container.clientWidth,this.container.clientHeight)),this.bloomPass.strength=.2,this.bloomPass.threshold=.6,this.bloomPass.radius=.6,this.composer.addPass(this.bloomPass),this.outputPass=new l,this.composer.addPass(this.outputPass),this.onResize()}init(){this.addLights(),this.initImage(),this.addEvents()}addLights(){var e=[];e[0]=new r(16777215,.55),e[0].position.set(3,0,0),e[1]=new r(1173691,1),e[1].position.set(4.75,8,.5),e[2]=new r(8519881,.5),e[2].position.set(-2.75,-1,.5),e[3]=new r(16777215,.5),e[3].position.set(5,3,-8),this.scene.add(e[0]),this.scene.add(e[1]),this.scene.add(e[2]),this.scene.add(e[3])}initImage(){this.img=new a(new c(4*new o(640,853).normalize().x,4*new o(640,853).normalize().y,240,240),new h({vertexShader:f.vertex,fragmentShader:f.fragment,uniforms:{uTexture1:{type:"sample2D",value:(new d).load(u)},uShineTexture1:{type:"sample2D",value:(new d).load(w)},uTime:{type:"float",value:0}},side:m})),this.scene.add(this.img)}addEvents(){window.requestAnimationFrame(this.run.bind(this)),window.addEventListener("resize",this.onResize.bind(this),!1)}run(){requestAnimationFrame(this.run.bind(this)),this.render()}render(){this.progress+=this.speed,this.img.position.z=.4*Math.sin(this.progress/2)-2,this.img.rotation.y=Math.PI*Math.sin(this.progress/2),this.bloomPass.strength=.3*Math.pow(Math.sin(this.progress),2),this.bloomPass.threshold=.6*Math.pow(Math.cos(this.progress),2),this.bloomPass.radius=Math.pow(Math.sin(this.progress),2),this.img.material.uniforms.uTime.value=this.progress,this.composer?this.composer.render():this.renderer.render(this.scene,this.camera)}onResize(){const e=this.container.clientWidth,n=this.container.clientHeight;this.camera.aspect=e/n,this.camera.updateProjectionMatrix(),this.renderer.setSize(e,n)}}export{g as App};
